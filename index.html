<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–¶–µ—Ü–æ - –°–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª–µ–Ω –ü—Ä–∞–≤–æ–ø–∏—Å–µ–Ω –ö–æ—Ä–µ–∫—Ç–æ—Ä</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
    textarea { width: 80%; height: 150px; font-size: 16px; padding: 10px; }
    button { padding: 8px 16px; margin: 5px; cursor: pointer; }
    #drop-area { border: 2px dashed #ccc; padding: 20px; margin: 10px auto; width: 80%; }
    #loading-status { padding: 10px; margin-bottom: 10px; font-weight: bold; }
    #result { margin-top: 20px; text-align: left; padding: 15px; border: 1px solid #ccc; min-height: 50px; }
    .error { color: red; font-weight: bold; text-decoration: underline; cursor: pointer; }
  </style>
</head>
<body>
<h2>üöÄ –¶–µ—Ü–æ - –ü—Ä–∞–≤–æ–ø–∏—Å–µ–Ω –ö–æ—Ä–µ–∫—Ç–æ—Ä v3.0</h2>
<div id="loading-status">–ó–∞—Ä–µ–∂–¥–∞–º —Ä–µ—á–Ω–∏–∫–∞...</div>
<textarea id="textInput" placeholder="–ù–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç –∏–ª–∏ –≤–ª–∞—á–∏ –∏ –ø—É—Å–Ω–∏ —Ñ–∞–π–ª —Ç—É–∫..."></textarea>
<br>
<div id="drop-area">–í–ª–∞—á–∏ –∏ –ø—É—Å–Ω–∏ —Ç–µ–∫—Å—Ç–æ–≤ —Ñ–∞–π–ª —Ç—É–∫ üìÇ</div>
<button onclick="checkText()">–ü—Ä–æ–≤–µ—Ä–∏ —Ç–µ–∫—Å—Ç üîç</button>
<button onclick="downloadText()">üì• –°–≤–∞–ª–∏ –∫–æ—Ä–∏–≥–∏—Ä–∞–Ω–∏—è —Ç–µ–∫—Å—Ç</button>
<div id="result"></div>

<script>
let bulgarianWords = [];
const corrections = {
  "–Ω–µ–º–æ–≥–∞": "–Ω–µ –º–æ–≥–∞",
  "–∞—Å": "–∞–∑",
  "—à—Ç–æ—Ç–æ": "–∑–∞—â–æ—Ç–æ",
  "–æ—Ç–∏–¥–æ—Ö–º–µ": "–æ—Ç–∏–¥–æ—Ö–º–µ",
  "–∫–æ–π—Ç–æ": "–∫–æ–∏—Ç–æ"
};

async function loadDictionary() {
  try {
    const response = await fetch('bulgarian_dict.txt');
    const data = await response.text();
    bulgarianWords = data.split("\n").map(word => word.trim().toLowerCase());
    document.getElementById("loading-status").innerText = "–†–µ—á–Ω–∏–∫—ä—Ç –µ –∑–∞—Ä–µ–¥–µ–Ω! ‚úÖ";
  } catch(e) {
    document.getElementById("loading-status").innerText = "–ü—Ä–æ–±–ª–µ–º –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Ä–µ—á–Ω–∏–∫–∞ ‚ùå";
    alert("–ü—Ä–æ–±–ª–µ–º —Å—ä—Å –∑–∞—Ä–µ–∂–¥–∞–Ω–µ—Ç–æ: " + e);
  }
}

function checkText() {
  const inputText = document.getElementById("textInput").value;
  const words = inputText.split(/(\s+)/);
  let correctedText = "";
  let hasErrors = false;

  let markedText = words.map(word => {
    let cleanWord = word.replace(/[^\p{L}]/gu, '').toLowerCase();
    if (cleanWord && !bulgarianWords.includes(cleanWord)) {
      hasErrors = true;
      let correction = corrections[cleanWord] || word;
      correctedText += correction + " ";
      return `<span class='error' title='–í—ä–∑–º–æ–∂–Ω–∞ –≥—Ä–µ—à–∫–∞'>${word}</span>`;
    } else {
      correctedText += word;
      return word;
    }
  }).join('');

  document.getElementById("textInput").innerHTML = markedText;
  document.getElementById("result").innerText = hasErrors ? correctedText.trim() : "";
}

// Drag and Drop
let dropArea = document.getElementById("drop-area");
dropArea.addEventListener("dragover", e => { e.preventDefault(); });
dropArea.addEventListener("drop", e => {
  e.preventDefault();
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = evt => { document.getElementById("textInput").value = evt.target.result; };
    reader.readAsText(file);
  }
});

// Download Text
function downloadText() {
  const text = document.getElementById("result").innerText;
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = "corrected_text.txt";
  a.click();
}

// –ó–∞—Ä–µ–¥–∏ —Ä–µ—á–Ω–∏–∫–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
loadDictionary();
</script>
</body>
</html>
